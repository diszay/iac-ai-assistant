# Proxmox Infrastructure as Code - Main Configuration
# Generated by Proxmox AI Assistant with security-first approach

terraform {
  required_version = ">= 1.0"
  required_providers {
    proxmox = {
      source  = "telmate/proxmox"
      version = "~> 2.9.14"
    }
    random = {
      source  = "hashicorp/random"
      version = "~> 3.4"
    }
    tls = {
      source  = "hashicorp/tls"
      version = "~> 4.0"
    }
  }
}

# Proxmox Provider Configuration
provider "proxmox" {
  pm_api_url          = var.proxmox_api_url
  pm_api_token_id     = var.proxmox_api_token_id
  pm_api_token_secret = var.proxmox_api_token_secret
  pm_tls_insecure     = var.proxmox_tls_insecure
  pm_parallel         = var.proxmox_parallel
  pm_timeout          = var.proxmox_timeout
  pm_debug            = var.proxmox_debug
}

# Data sources for existing Proxmox resources
data "proxmox_version" "version" {}

# Local values for consistent naming and configuration
locals {
  # Naming convention: {environment}-{application}-{component}-{instance}
  name_prefix = "${var.environment}-${var.application_name}"
  
  # Common tags for all resources
  common_tags = {
    Environment   = var.environment
    Application   = var.application_name
    ManagedBy     = "terraform"
    CreatedBy     = "proxmox-ai-assistant"
    SecurityLevel = var.security_level
    Project       = var.project_name
  }
  
  # Security-hardened VM defaults
  vm_defaults = {
    cpu_cores    = var.default_cpu_cores
    memory       = var.default_memory
    disk_size    = var.default_disk_size
    disk_type    = "scsi"
    disk_storage = var.proxmox_storage
    network_model = "virtio"
    os_type      = "l26"  # Linux 2.6+ Kernel
    
    # Security settings
    boot_order      = "order=scsi0"
    bios           = "ovmf"  # UEFI for modern security features
    machine        = "q35"   # Modern machine type
    protection     = true    # Enable deletion protection
    hotplug        = "network,disk"
    
    # Cloud-init settings
    ciuser         = var.default_username
    sshkeys        = var.ssh_public_keys
    ipconfig0      = "ip=dhcp"
    searchdomain   = var.search_domain
    nameserver     = var.nameservers
  }
  
  # Network configuration
  network_config = {
    bridge         = var.network_bridge
    vlan_tag       = var.vlan_tag
    firewall       = true
    link_down      = false
    macaddr        = null  # Auto-generate
    mtu            = var.network_mtu
    queues         = var.network_queues
    rate           = var.network_rate_limit
  }
}

# Generate SSH key pair for VMs if not provided
resource "tls_private_key" "vm_ssh_key" {
  count     = var.generate_ssh_key ? 1 : 0
  algorithm = "ED25519"
}

# Store SSH public key for VM access
resource "local_file" "ssh_public_key" {
  count    = var.generate_ssh_key ? 1 : 0
  content  = tls_private_key.vm_ssh_key[0].public_key_openssh
  filename = "${path.module}/generated-keys/vm_key.pub"
  
  file_permission = "0644"
  
  provisioner "local-exec" {
    command = "mkdir -p ${path.module}/generated-keys"
  }
}

# Store SSH private key securely
resource "local_sensitive_file" "ssh_private_key" {
  count    = var.generate_ssh_key ? 1 : 0
  content  = tls_private_key.vm_ssh_key[0].private_key_openssh
  filename = "${path.module}/generated-keys/vm_key"
  
  file_permission = "0600"
}

# Random password for VM user account
resource "random_password" "vm_password" {
  count   = var.generate_vm_password ? 1 : 0
  length  = 32
  special = true
  upper   = true
  lower   = true
  numeric = true
}

# Cloud-init configuration template
data "template_file" "cloud_init" {
  count    = var.enable_cloud_init ? 1 : 0
  template = file("${path.module}/templates/cloud-init.yaml")
  
  vars = {
    username          = var.default_username
    ssh_authorized_keys = var.generate_ssh_key ? tls_private_key.vm_ssh_key[0].public_key_openssh : var.ssh_public_keys
    password_hash     = var.generate_vm_password ? bcrypt(random_password.vm_password[0].result, 12) : var.password_hash
    hostname          = "${local.name_prefix}-${var.instance_name}"
    domain            = var.search_domain
    timezone          = var.timezone
    locale            = var.locale
    packages          = jsonencode(var.default_packages)
    security_updates  = var.enable_automatic_security_updates
    fail2ban_enabled  = var.enable_fail2ban
    ufw_enabled       = var.enable_ufw_firewall
    docker_enabled    = var.enable_docker
    monitoring_enabled = var.enable_monitoring
  }
}

# Main VM resource
resource "proxmox_vm_qemu" "main" {
  count = var.vm_count
  
  # Basic VM configuration
  name         = "${local.name_prefix}-${var.instance_name}-${format("%02d", count.index + 1)}"
  desc         = "Managed by Terraform - ${var.description}"
  target_node  = var.proxmox_node
  clone        = var.template_name
  full_clone   = var.full_clone
  
  # VM specifications
  cores     = local.vm_defaults.cpu_cores
  sockets   = var.cpu_sockets
  vcpus     = var.cpu_vcpus > 0 ? var.cpu_vcpus : null
  cpu       = var.cpu_type
  memory    = local.vm_defaults.memory
  balloon   = var.memory_balloon
  
  # Security and boot configuration
  bios         = local.vm_defaults.bios
  machine      = local.vm_defaults.machine
  boot         = local.vm_defaults.boot_order
  protection   = local.vm_defaults.protection
  hotplug      = local.vm_defaults.hotplug
  
  # Operating system
  os_type = local.vm_defaults.os_type
  
  # Agent configuration
  agent = var.enable_qemu_agent ? 1 : 0
  
  # VM startup configuration
  startup    = var.vm_startup_order
  onboot     = var.vm_autostart
  vm_state   = var.initial_vm_state
  
  # Primary disk configuration
  disk {
    slot     = 0
    type     = local.vm_defaults.disk_type
    storage  = local.vm_defaults.disk_storage
    size     = local.vm_defaults.disk_size
    format   = var.disk_format
    cache    = var.disk_cache
    backup   = var.disk_backup
    iothread = var.disk_iothread
    discard  = var.disk_discard
    ssd      = var.disk_ssd
  }
  
  # Additional data disks
  dynamic "disk" {
    for_each = var.additional_disks
    content {
      slot     = disk.value.slot
      type     = disk.value.type
      storage  = disk.value.storage
      size     = disk.value.size
      format   = disk.value.format
      cache    = disk.value.cache
      backup   = disk.value.backup
      iothread = disk.value.iothread
      discard  = disk.value.discard
      ssd      = disk.value.ssd
    }
  }
  
  # Network configuration
  network {
    model    = local.vm_defaults.network_model
    bridge   = local.network_config.bridge
    tag      = local.network_config.vlan_tag
    firewall = local.network_config.firewall
    macaddr  = var.mac_addresses != null ? var.mac_addresses[count.index] : null
    mtu      = local.network_config.mtu
    queues   = local.network_config.queues
    rate     = local.network_config.rate
  }
  
  # Additional network interfaces
  dynamic "network" {
    for_each = var.additional_networks
    content {
      model    = network.value.model
      bridge   = network.value.bridge
      tag      = network.value.vlan_tag
      firewall = network.value.firewall
      macaddr  = network.value.macaddr
      mtu      = network.value.mtu
      queues   = network.value.queues
      rate     = network.value.rate
    }
  }
  
  # Cloud-init configuration
  ciuser       = local.vm_defaults.ciuser
  cipassword   = var.generate_vm_password ? random_password.vm_password[0].result : var.ci_password
  sshkeys      = var.generate_ssh_key ? tls_private_key.vm_ssh_key[0].public_key_openssh : var.ssh_public_keys
  ipconfig0    = var.ip_config != null ? var.ip_config[count.index] : local.vm_defaults.ipconfig0
  ipconfig1    = var.additional_ip_configs != null ? var.additional_ip_configs[count.index] : null
  searchdomain = local.vm_defaults.searchdomain
  nameserver   = local.vm_defaults.nameserver
  
  # Custom cloud-init file
  cicustom = var.enable_cloud_init ? "user=local:snippets/cloud-init-${count.index}.yml" : null
  
  # USB devices
  dynamic "usb" {
    for_each = var.usb_devices
    content {
      host = usb.value.host
      usb3 = usb.value.usb3
    }
  }
  
  # Serial devices
  dynamic "serial" {
    for_each = var.serial_devices
    content {
      id   = serial.value.id
      type = serial.value.type
    }
  }
  
  # Lifecycle management
  lifecycle {
    create_before_destroy = var.create_before_destroy
    ignore_changes = [
      # Ignore changes to network MAC addresses if auto-generated
      network[0].macaddr,
    ]
  }
  
  # Provisioning connection
  connection {
    type        = "ssh"
    user        = local.vm_defaults.ciuser
    private_key = var.generate_ssh_key ? tls_private_key.vm_ssh_key[0].private_key_openssh : var.ssh_private_key
    host        = var.connection_host != null ? var.connection_host[count.index] : self.default_ipv4_address
    port        = var.ssh_port
    timeout     = var.connection_timeout
  }
  
  # Wait for cloud-init to complete
  provisioner "remote-exec" {
    inline = [
      "cloud-init status --wait",
      "sudo systemctl is-active --quiet cloud-init-local.service",
      "sudo systemctl is-active --quiet cloud-init.service",
      "sudo systemctl is-active --quiet cloud-config.service",
      "sudo systemctl is-active --quiet cloud-final.service"
    ]
  }
  
  # Initial security hardening
  provisioner "remote-exec" {
    inline = var.enable_initial_hardening ? [
      "sudo apt-get update -y",
      "sudo apt-get upgrade -y",
      "sudo ufw --force enable",
      "sudo systemctl enable fail2ban",
      "sudo systemctl start fail2ban"
    ] : []
  }
  
  # Custom provisioning scripts
  dynamic "provisioner" {
    for_each = var.provisioning_scripts
    content {
      type = "remote-exec"
      inline = provisioner.value.commands
    }
  }
  
  # File uploads
  dynamic "provisioner" {
    for_each = var.file_uploads
    content {
      type        = "file"
      source      = provisioner.value.source
      destination = provisioner.value.destination
    }
  }
  
  # VM tags for organization
  tags = join(";", [
    for k, v in local.common_tags : "${k}:${v}"
  ])
  
  depends_on = [
    tls_private_key.vm_ssh_key,
    random_password.vm_password
  ]
}

# Generate inventory file for Ansible
resource "local_file" "ansible_inventory" {
  count = var.generate_ansible_inventory ? 1 : 0
  
  content = templatefile("${path.module}/templates/inventory.tpl", {
    vms = [
      for vm in proxmox_vm_qemu.main : {
        name = vm.name
        ip   = vm.default_ipv4_address
        user = local.vm_defaults.ciuser
      }
    ]
    ssh_private_key = var.generate_ssh_key ? "${path.module}/generated-keys/vm_key" : var.ssh_private_key_path
  })
  
  filename        = "${path.module}/inventory/hosts.yml"
  file_permission = "0644"
  
  provisioner "local-exec" {
    command = "mkdir -p ${path.module}/inventory"
  }
}

# Output important information
output "vm_details" {
  description = "Details of created VMs"
  value = [
    for vm in proxmox_vm_qemu.main : {
      name              = vm.name
      id                = vm.vmid
      node              = vm.target_node
      ip_address        = vm.default_ipv4_address
      mac_address       = vm.network[0].macaddr
      ssh_user          = local.vm_defaults.ciuser
      status            = "created"
    }
  ]
}

output "ssh_connection_commands" {
  description = "SSH connection commands for each VM"
  value = [
    for i, vm in proxmox_vm_qemu.main : 
    "ssh -i ${var.generate_ssh_key ? "${path.module}/generated-keys/vm_key" : var.ssh_private_key_path} ${local.vm_defaults.ciuser}@${vm.default_ipv4_address}"
  ]
}

output "generated_ssh_key_path" {
  description = "Path to generated SSH private key"
  value = var.generate_ssh_key ? "${path.module}/generated-keys/vm_key" : null
  sensitive = true
}

output "vm_passwords" {
  description = "Generated VM passwords"
  value = var.generate_vm_password ? [
    for pwd in random_password.vm_password : pwd.result
  ] : []
  sensitive = true
}

output "ansible_inventory_path" {
  description = "Path to generated Ansible inventory"
  value = var.generate_ansible_inventory ? "${path.module}/inventory/hosts.yml" : null
}