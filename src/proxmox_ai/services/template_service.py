"""
Template management service for Proxmox AI Assistant.

Provides comprehensive template management including VM templates, 
infrastructure templates, and automated provisioning templates.
"""

import json
import yaml
from pathlib import Path
from typing import Dict, Any, List, Optional, Union
from dataclasses import dataclass, asdict
from enum import Enum

import structlog
from jinja2 import Template, Environment, FileSystemLoader, TemplateNotFound

from ..core.config import get_settings
from ..core.logging import log_security_event

logger = structlog.get_logger(__name__)


class TemplateType(Enum):
    """Template type enumeration."""
    VM = "vm"
    TERRAFORM = "terraform"
    ANSIBLE = "ansible"
    DOCKER = "docker"
    KUBERNETES = "kubernetes"


class TemplateError(Exception):
    """Raised when template operations fail."""
    pass


@dataclass
class TemplateMetadata:
    """Template metadata information."""
    name: str
    description: str
    version: str
    author: str
    created_at: str
    updated_at: str
    template_type: TemplateType
    tags: List[str]
    variables: Dict[str, Any]
    requirements: Dict[str, Any]


@dataclass
class Template:
    """Template definition."""
    metadata: TemplateMetadata
    content: str
    variables: Dict[str, Any]
    validation_rules: Optional[Dict[str, Any]] = None
    dependencies: Optional[List[str]] = None


class TemplateService:
    """
    Comprehensive template management service.
    
    Provides template storage, retrieval, rendering, and management
    for various infrastructure components.
    """
    
    def __init__(self):
        self.settings = get_settings()
        self.template_dir = self.settings.data_dir / "templates"
        self.custom_template_dir = self.settings.data_dir / "custom_templates"
        
        # Ensure template directories exist
        self.template_dir.mkdir(parents=True, exist_ok=True)
        self.custom_template_dir.mkdir(parents=True, exist_ok=True)
        
        # Initialize Jinja2 environment
        self.jinja_env = Environment(
            loader=FileSystemLoader([
                str(self.template_dir),
                str(self.custom_template_dir)
            ]),
            autoescape=False,
            trim_blocks=True,
            lstrip_blocks=True
        )
        
        self._builtin_templates = {}
        self._load_builtin_templates()
        
        logger.info("Template service initialized", template_dir=str(self.template_dir))
    
    def _load_builtin_templates(self):
        """Load built-in templates."""
        
        # VM Templates
        self._builtin_templates.update({
            'vm/ubuntu-server': Template(
                metadata=TemplateMetadata(
                    name="Ubuntu Server",
                    description="Ubuntu 22.04 LTS Server VM",
                    version="1.0.0",
                    author="Proxmox AI Assistant",
                    created_at="2024-01-01T00:00:00Z",
                    updated_at="2024-01-01T00:00:00Z",
                    template_type=TemplateType.VM,
                    tags=["ubuntu", "linux", "server"],
                    variables={
                        "name": {"type": "string", "required": True, "description": "VM name"},
                        "memory": {"type": "integer", "default": 2048, "description": "Memory in MB"},
                        "cores": {"type": "integer", "default": 2, "description": "CPU cores"},
                        "disk_size": {"type": "string", "default": "32G", "description": "Disk size"},
                        "network_bridge": {"type": "string", "default": "vmbr0", "description": "Network bridge"}
                    },
                    requirements={"proxmox_version": ">=7.0"}
                ),
                content="""
{
  "name": "{{ name }}",
  "memory": {{ memory }},
  "cores": {{ cores }},
  "ostype": "l26",
  "net0": "virtio,bridge={{ network_bridge }}",
  "virtio0": "local-lvm:{{ disk_size }}",
  "agent": "1",
  "boot": "order=virtio0",
  "description": "{{ name }} - Ubuntu 22.04 LTS Server (Generated by template)"
}
""".strip(),
                variables={}
            ),
            
            'vm/centos-server': Template(
                metadata=TemplateMetadata(
                    name="CentOS Server",
                    description="CentOS 9 Stream Server VM",
                    version="1.0.0",
                    author="Proxmox AI Assistant",
                    created_at="2024-01-01T00:00:00Z",
                    updated_at="2024-01-01T00:00:00Z",
                    template_type=TemplateType.VM,
                    tags=["centos", "linux", "server"],
                    variables={
                        "name": {"type": "string", "required": True},
                        "memory": {"type": "integer", "default": 2048},
                        "cores": {"type": "integer", "default": 2},
                        "disk_size": {"type": "string", "default": "32G"},
                        "network_bridge": {"type": "string", "default": "vmbr0"}
                    },
                    requirements={"proxmox_version": ">=7.0"}
                ),
                content="""
{
  "name": "{{ name }}",
  "memory": {{ memory }},
  "cores": {{ cores }},
  "ostype": "l26",
  "net0": "virtio,bridge={{ network_bridge }}",
  "virtio0": "local-lvm:{{ disk_size }}",
  "agent": "1",
  "boot": "order=virtio0",
  "description": "{{ name }} - CentOS 9 Stream Server (Generated by template)"
}
""".strip(),
                variables={}
            ),
            
            'vm/windows-server': Template(
                metadata=TemplateMetadata(
                    name="Windows Server",
                    description="Windows Server 2022 VM",
                    version="1.0.0",
                    author="Proxmox AI Assistant",
                    created_at="2024-01-01T00:00:00Z",
                    updated_at="2024-01-01T00:00:00Z",
                    template_type=TemplateType.VM,
                    tags=["windows", "server"],
                    variables={
                        "name": {"type": "string", "required": True},
                        "memory": {"type": "integer", "default": 4096},
                        "cores": {"type": "integer", "default": 4},
                        "disk_size": {"type": "string", "default": "60G"},
                        "network_bridge": {"type": "string", "default": "vmbr0"}
                    },
                    requirements={"proxmox_version": ">=7.0"}
                ),
                content="""
{
  "name": "{{ name }}",
  "memory": {{ memory }},
  "cores": {{ cores }},
  "ostype": "win11",
  "net0": "virtio,bridge={{ network_bridge }}",
  "virtio0": "local-lvm:{{ disk_size }}",
  "ide2": "local:iso/virtio-win.iso,media=cdrom",
  "boot": "order=virtio0",
  "description": "{{ name }} - Windows Server 2022 (Generated by template)"
}
""".strip(),
                variables={}
            )
        })
        
        # Terraform Templates
        self._builtin_templates.update({
            'terraform/proxmox-vm': Template(
                metadata=TemplateMetadata(
                    name="Proxmox VM",
                    description="Basic Proxmox VM with Terraform",
                    version="1.0.0",
                    author="Proxmox AI Assistant",
                    created_at="2024-01-01T00:00:00Z",
                    updated_at="2024-01-01T00:00:00Z",
                    template_type=TemplateType.TERRAFORM,
                    tags=["terraform", "proxmox", "vm"],
                    variables={
                        "vm_name": {"type": "string", "required": True},
                        "target_node": {"type": "string", "required": True},
                        "vm_id": {"type": "integer", "required": True},
                        "memory": {"type": "integer", "default": 2048},
                        "cores": {"type": "integer", "default": 2}
                    },
                    requirements={"terraform": ">=1.0"}
                ),
                content="""
terraform {
  required_providers {
    proxmox = {
      source  = "telmate/proxmox"
      version = "~> 2.9"
    }
  }
}

provider "proxmox" {
  pm_api_url      = var.proxmox_api_url
  pm_user         = var.proxmox_user
  pm_password     = var.proxmox_password
  pm_tls_insecure = var.proxmox_tls_insecure
}

variable "proxmox_api_url" {
  description = "Proxmox API URL"
  type        = string
}

variable "proxmox_user" {
  description = "Proxmox username"
  type        = string
}

variable "proxmox_password" {
  description = "Proxmox password"
  type        = string
  sensitive   = true
}

variable "proxmox_tls_insecure" {
  description = "Skip TLS verification"
  type        = bool
  default     = false
}

resource "proxmox_vm_qemu" "{{ vm_name }}" {
  name        = "{{ vm_name }}"
  target_node = "{{ target_node }}"
  vmid        = {{ vm_id }}
  
  # VM Configuration
  memory = {{ memory }}
  cores  = {{ cores }}
  
  # Disk Configuration
  disk {
    size    = "32G"
    type    = "virtio"
    storage = "local-lvm"
  }
  
  # Network Configuration
  network {
    model  = "virtio"
    bridge = "vmbr0"
  }
  
  # OS Configuration
  os_type = "cloud-init"
  
  # Cloud-init configuration
  ciuser     = "ubuntu"
  cipassword = "ubuntu"
  
  # SSH Keys
  sshkeys = <<-EOT
    # Add your SSH public keys here
  EOT
  
  tags = "terraform,{{ vm_name }}"
}

output "vm_ip" {
  description = "VM IP address"
  value       = proxmox_vm_qemu.{{ vm_name }}.default_ipv4_address
}

output "vm_id" {
  description = "VM ID"
  value       = proxmox_vm_qemu.{{ vm_name }}.vmid
}
""".strip(),
                variables={}
            ),
            
            'terraform/multi-vm-cluster': Template(
                metadata=TemplateMetadata(
                    name="Multi-VM Cluster",
                    description="Multiple VMs for cluster deployment",
                    version="1.0.0",
                    author="Proxmox AI Assistant",
                    created_at="2024-01-01T00:00:00Z",
                    updated_at="2024-01-01T00:00:00Z",
                    template_type=TemplateType.TERRAFORM,
                    tags=["terraform", "cluster", "multi-vm"],
                    variables={
                        "cluster_name": {"type": "string", "required": True},
                        "vm_count": {"type": "integer", "default": 3},
                        "target_node": {"type": "string", "required": True}
                    },
                    requirements={"terraform": ">=1.0"}
                ),
                content="""
terraform {
  required_providers {
    proxmox = {
      source  = "telmate/proxmox"
      version = "~> 2.9"
    }
  }
}

provider "proxmox" {
  pm_api_url      = var.proxmox_api_url
  pm_user         = var.proxmox_user
  pm_password     = var.proxmox_password
  pm_tls_insecure = var.proxmox_tls_insecure
}

variable "proxmox_api_url" {
  description = "Proxmox API URL"
  type        = string
}

variable "proxmox_user" {
  description = "Proxmox username"
  type        = string
}

variable "proxmox_password" {
  description = "Proxmox password"
  type        = string
  sensitive   = true
}

variable "proxmox_tls_insecure" {
  description = "Skip TLS verification"
  type        = bool
  default     = false
}

resource "proxmox_vm_qemu" "{{ cluster_name }}_node" {
  count       = {{ vm_count }}
  name        = "{{ cluster_name }}-node-${count.index + 1}"
  target_node = "{{ target_node }}"
  vmid        = 200 + count.index
  
  # VM Configuration
  memory = 2048
  cores  = 2
  
  # Disk Configuration
  disk {
    size    = "32G"
    type    = "virtio"
    storage = "local-lvm"
  }
  
  # Network Configuration
  network {
    model  = "virtio"
    bridge = "vmbr0"
  }
  
  # OS Configuration
  os_type = "cloud-init"
  
  # Cloud-init configuration
  ciuser     = "ubuntu"
  cipassword = "ubuntu"
  
  tags = "terraform,{{ cluster_name }},cluster-node"
}

output "cluster_ips" {
  description = "Cluster node IP addresses"
  value       = proxmox_vm_qemu.{{ cluster_name }}_node[*].default_ipv4_address
}

output "cluster_ids" {
  description = "Cluster node VM IDs"
  value       = proxmox_vm_qemu.{{ cluster_name }}_node[*].vmid
}
""".strip(),
                variables={}
            )
        })
        
        # Ansible Templates
        self._builtin_templates.update({
            'ansible/web-server-setup': Template(
                metadata=TemplateMetadata(
                    name="Web Server Setup",
                    description="Install and configure NGINX web server",
                    version="1.0.0",
                    author="Proxmox AI Assistant",
                    created_at="2024-01-01T00:00:00Z",
                    updated_at="2024-01-01T00:00:00Z",
                    template_type=TemplateType.ANSIBLE,
                    tags=["ansible", "nginx", "web", "server"],
                    variables={
                        "server_name": {"type": "string", "default": "example.com"},
                        "document_root": {"type": "string", "default": "/var/www/html"},
                        "enable_ssl": {"type": "boolean", "default": False}
                    },
                    requirements={"ansible": ">=2.9"}
                ),
                content="""
---
- name: Configure Web Server
  hosts: webservers
  become: yes
  vars:
    server_name: "{{ server_name | default('example.com') }}"
    document_root: "{{ document_root | default('/var/www/html') }}"
    enable_ssl: {{ enable_ssl | default(false) | lower }}
  
  tasks:
    - name: Update package cache
      apt:
        update_cache: yes
      when: ansible_os_family == "Debian"
    
    - name: Install NGINX
      package:
        name: nginx
        state: present
    
    - name: Create document root directory
      file:
        path: "{{ document_root }}"
        state: directory
        owner: www-data
        group: www-data
        mode: '0755'
    
    - name: Create NGINX site configuration
      template:
        src: nginx-site.conf.j2
        dest: "/etc/nginx/sites-available/{{ server_name }}"
        backup: yes
      notify: restart nginx
    
    - name: Enable site
      file:
        src: "/etc/nginx/sites-available/{{ server_name }}"
        dest: "/etc/nginx/sites-enabled/{{ server_name }}"
        state: link
      notify: restart nginx
    
    - name: Remove default site
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      notify: restart nginx
    
    - name: Create sample index page
      copy:
        content: |
          <!DOCTYPE html>
          <html>
          <head>
              <title>Welcome to {{ server_name }}</title>
          </head>
          <body>
              <h1>Welcome to {{ server_name }}</h1>
              <p>This server was configured with Proxmox AI Assistant.</p>
          </body>
          </html>
        dest: "{{ document_root }}/index.html"
        owner: www-data
        group: www-data
        mode: '0644'
    
    - name: Start and enable NGINX
      systemd:
        name: nginx
        state: started
        enabled: yes
    
    - name: Open firewall for HTTP
      ufw:
        rule: allow
        port: '80'
        proto: tcp
      when: ansible_os_family == "Debian"
    
    - name: Open firewall for HTTPS
      ufw:
        rule: allow
        port: '443'
        proto: tcp
      when: enable_ssl and ansible_os_family == "Debian"
  
  handlers:
    - name: restart nginx
      systemd:
        name: nginx
        state: restarted
""".strip(),
                variables={}
            ),
            
            'ansible/docker-setup': Template(
                metadata=TemplateMetadata(
                    name="Docker Setup",
                    description="Install and configure Docker on Ubuntu/CentOS",
                    version="1.0.0",
                    author="Proxmox AI Assistant",
                    created_at="2024-01-01T00:00:00Z",
                    updated_at="2024-01-01T00:00:00Z",
                    template_type=TemplateType.ANSIBLE,
                    tags=["ansible", "docker", "container"],
                    variables={
                        "docker_users": {"type": "list", "default": ["ubuntu"]},
                        "install_compose": {"type": "boolean", "default": True}
                    },
                    requirements={"ansible": ">=2.9"}
                ),
                content="""
---
- name: Install and Configure Docker
  hosts: docker_hosts
  become: yes
  vars:
    docker_users: {{ docker_users | default(['ubuntu']) | to_json }}
    install_compose: {{ install_compose | default(true) | lower }}
  
  tasks:
    - name: Update package cache (Ubuntu/Debian)
      apt:
        update_cache: yes
      when: ansible_os_family == "Debian"
    
    - name: Install prerequisites (Ubuntu/Debian)
      apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
        state: present
      when: ansible_os_family == "Debian"
    
    - name: Add Docker GPG key (Ubuntu/Debian)
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present
      when: ansible_os_family == "Debian"
    
    - name: Add Docker repository (Ubuntu/Debian)
      apt_repository:
        repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        state: present
      when: ansible_os_family == "Debian"
    
    - name: Install Docker (Ubuntu/Debian)
      apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
        state: present
        update_cache: yes
      when: ansible_os_family == "Debian"
    
    - name: Install Docker (CentOS/RHEL)
      yum:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
        state: present
      when: ansible_os_family == "RedHat"
    
    - name: Start and enable Docker service
      systemd:
        name: docker
        state: started
        enabled: yes
    
    - name: Add users to docker group
      user:
        name: "{{ item }}"
        groups: docker
        append: yes
      loop: "{{ docker_users }}"
    
    - name: Install Docker Compose
      pip:
        name: docker-compose
        state: present
      when: install_compose
    
    - name: Create Docker daemon configuration
      copy:
        content: |
          {
            "log-driver": "json-file",
            "log-opts": {
              "max-size": "10m",
              "max-file": "3"
            }
          }
        dest: /etc/docker/daemon.json
        backup: yes
      notify: restart docker
  
  handlers:
    - name: restart docker
      systemd:
        name: docker
        state: restarted
""".strip(),
                variables={}
            )
        })
        
        # Docker Compose Templates
        self._builtin_templates.update({
            'docker/lamp-stack': Template(
                metadata=TemplateMetadata(
                    name="LAMP Stack",
                    description="Apache, MySQL, PHP stack with Docker Compose",
                    version="1.0.0",
                    author="Proxmox AI Assistant",
                    created_at="2024-01-01T00:00:00Z",
                    updated_at="2024-01-01T00:00:00Z",
                    template_type=TemplateType.DOCKER,
                    tags=["docker", "lamp", "apache", "mysql", "php"],
                    variables={
                        "mysql_root_password": {"type": "string", "required": True},
                        "app_name": {"type": "string", "default": "webapp"},
                        "php_version": {"type": "string", "default": "8.2"}
                    },
                    requirements={"docker": ">=20.0", "docker-compose": ">=2.0"}
                ),
                content="""
version: '3.8'

services:
  apache:
    image: php:{{ php_version }}-apache
    container_name: {{ app_name }}_apache
    restart: unless-stopped
    ports:
      - "80:80"
    volumes:
      - ./html:/var/www/html
      - ./apache/apache2.conf:/etc/apache2/apache2.conf
    depends_on:
      - mysql
    environment:
      - MYSQL_HOST=mysql
      - MYSQL_DATABASE={{ app_name }}
      - MYSQL_USER={{ app_name }}
      - MYSQL_PASSWORD={{ mysql_root_password }}
    networks:
      - {{ app_name }}_network

  mysql:
    image: mysql:8.0
    container_name: {{ app_name }}_mysql
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: {{ mysql_root_password }}
      MYSQL_DATABASE: {{ app_name }}
      MYSQL_USER: {{ app_name }}
      MYSQL_PASSWORD: {{ mysql_root_password }}
    volumes:
      - mysql_data:/var/lib/mysql
      - ./mysql/init:/docker-entrypoint-initdb.d
    ports:
      - "3306:3306"
    networks:
      - {{ app_name }}_network

  phpmyadmin:
    image: phpmyadmin/phpmyadmin:latest
    container_name: {{ app_name }}_phpmyadmin
    restart: unless-stopped
    environment:
      PMA_HOST: mysql
      PMA_PORT: 3306
      MYSQL_ROOT_PASSWORD: {{ mysql_root_password }}
    ports:
      - "8080:80"
    depends_on:
      - mysql
    networks:
      - {{ app_name }}_network

volumes:
  mysql_data:
    driver: local

networks:
  {{ app_name }}_network:
    driver: bridge
""".strip(),
                variables={}
            ),
            
            'docker/monitoring-stack': Template(
                metadata=TemplateMetadata(
                    name="Monitoring Stack",
                    description="Prometheus, Grafana, and Node Exporter monitoring stack",
                    version="1.0.0",
                    author="Proxmox AI Assistant",
                    created_at="2024-01-01T00:00:00Z",
                    updated_at="2024-01-01T00:00:00Z",
                    template_type=TemplateType.DOCKER,
                    tags=["docker", "monitoring", "prometheus", "grafana"],
                    variables={
                        "grafana_admin_password": {"type": "string", "required": True},
                        "stack_name": {"type": "string", "default": "monitoring"}
                    },
                    requirements={"docker": ">=20.0", "docker-compose": ">=2.0"}
                ),
                content="""
version: '3.8'

services:
  prometheus:
    image: prom/prometheus:latest
    container_name: {{ stack_name }}_prometheus
    restart: unless-stopped
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=200h'
      - '--web.enable-lifecycle'
    networks:
      - {{ stack_name }}_network

  grafana:
    image: grafana/grafana:latest
    container_name: {{ stack_name }}_grafana
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      GF_SECURITY_ADMIN_PASSWORD: {{ grafana_admin_password }}
      GF_INSTALL_PLUGINS: grafana-piechart-panel
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning
    depends_on:
      - prometheus
    networks:
      - {{ stack_name }}_network

  node-exporter:
    image: prom/node-exporter:latest
    container_name: {{ stack_name }}_node_exporter
    restart: unless-stopped
    ports:
      - "9100:9100"
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    command:
      - '--path.procfs=/host/proc'
      - '--path.rootfs=/rootfs'
      - '--path.sysfs=/host/sys'
      - '--collector.filesystem.mount-points-exclude=^/(sys|proc|dev|host|etc)($$|/)'
    networks:
      - {{ stack_name }}_network

  cadvisor:
    image: gcr.io/cadvisor/cadvisor:latest
    container_name: {{ stack_name }}_cadvisor
    restart: unless-stopped
    ports:
      - "8081:8080"
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:rw
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
    networks:
      - {{ stack_name }}_network

volumes:
  prometheus_data:
    driver: local
  grafana_data:
    driver: local

networks:
  {{ stack_name }}_network:
    driver: bridge
""".strip(),
                variables={}
            )
        })
    
    def list_templates(
        self, 
        template_type: Optional[TemplateType] = None,
        tags: Optional[List[str]] = None,
        include_custom: bool = True
    ) -> Dict[str, Template]:
        """
        List available templates with optional filtering.
        
        Args:
            template_type: Filter by template type
            tags: Filter by tags
            include_custom: Include custom templates
            
        Returns:
            Dict of template name to Template objects
        """
        templates = self._builtin_templates.copy()
        
        # Load custom templates if requested
        if include_custom:
            custom_templates = self._load_custom_templates()
            templates.update(custom_templates)
        
        # Apply filters
        if template_type:
            templates = {
                name: template for name, template in templates.items()
                if template.metadata.template_type == template_type
            }
        
        if tags:
            templates = {
                name: template for name, template in templates.items()
                if any(tag in template.metadata.tags for tag in tags)
            }
        
        logger.debug("Listed templates", count=len(templates), type=template_type, tags=tags)
        return templates
    
    def get_template(self, name: str) -> Template:
        """
        Get a specific template by name.
        
        Args:
            name: Template name
            
        Returns:
            Template object
            
        Raises:
            TemplateError: If template not found
        """
        # Check built-in templates
        if name in self._builtin_templates:
            return self._builtin_templates[name]
        
        # Check custom templates
        custom_templates = self._load_custom_templates()
        if name in custom_templates:
            return custom_templates[name]
        
        raise TemplateError(f"Template '{name}' not found")
    
    def render_template(
        self, 
        template_name: str, 
        variables: Dict[str, Any],
        validate_variables: bool = True
    ) -> str:
        """
        Render a template with provided variables.
        
        Args:
            template_name: Name of template to render
            variables: Variables to substitute
            validate_variables: Whether to validate variables
            
        Returns:
            Rendered template content
            
        Raises:
            TemplateError: If rendering fails
        """
        try:
            template = self.get_template(template_name)
            
            # Validate variables if requested
            if validate_variables:
                self._validate_template_variables(template, variables)
            
            # Render template
            jinja_template = self.jinja_env.from_string(template.content)
            rendered = jinja_template.render(**variables)
            
            log_security_event(
                "Template rendered",
                success=True,
                details={
                    'template_name': template_name,
                    'variable_count': len(variables)
                }
            )
            
            logger.info("Template rendered", template=template_name, variables=len(variables))
            return rendered
            
        except TemplateNotFound as e:
            raise TemplateError(f"Template file not found: {e}")
        except Exception as e:
            logger.error("Template rendering failed", template=template_name, error=str(e))
            raise TemplateError(f"Template rendering failed: {e}")
    
    def _validate_template_variables(self, template: Template, variables: Dict[str, Any]):
        """Validate provided variables against template requirements."""
        errors = []
        template_vars = template.metadata.variables
        
        # Check required variables
        for var_name, var_config in template_vars.items():
            if var_config.get('required', False) and var_name not in variables:
                errors.append(f"Required variable '{var_name}' not provided")
        
        # Type validation (basic)
        for var_name, value in variables.items():
            if var_name in template_vars:
                var_config = template_vars[var_name]
                expected_type = var_config.get('type')
                
                if expected_type == 'integer' and not isinstance(value, int):
                    try:
                        variables[var_name] = int(value)
                    except (ValueError, TypeError):
                        errors.append(f"Variable '{var_name}' must be an integer")
                
                elif expected_type == 'boolean' and not isinstance(value, bool):
                    if isinstance(value, str):
                        variables[var_name] = value.lower() in ('true', '1', 'yes', 'on')
                    else:
                        errors.append(f"Variable '{var_name}' must be a boolean")
        
        if errors:
            raise TemplateError("Variable validation failed: " + "; ".join(errors))
    
    def save_custom_template(
        self, 
        name: str, 
        template: Template,
        overwrite: bool = False
    ):
        """
        Save a custom template to disk.
        
        Args:
            name: Template name
            template: Template object
            overwrite: Whether to overwrite existing template
            
        Raises:
            TemplateError: If save fails or template exists
        """
        try:
            template_file = self.custom_template_dir / f"{name}.json"
            
            if template_file.exists() and not overwrite:
                raise TemplateError(f"Template '{name}' already exists. Use overwrite=True to replace.")
            
            # Convert template to dict for serialization
            template_dict = {
                'metadata': asdict(template.metadata),
                'content': template.content,
                'variables': template.variables,
                'validation_rules': template.validation_rules,
                'dependencies': template.dependencies
            }
            
            # Convert enum to string
            template_dict['metadata']['template_type'] = template.metadata.template_type.value
            
            with open(template_file, 'w') as f:
                json.dump(template_dict, f, indent=2)
            
            logger.info("Custom template saved", name=name, file=str(template_file))
            
        except Exception as e:
            logger.error("Failed to save custom template", name=name, error=str(e))
            raise TemplateError(f"Failed to save template: {e}")
    
    def _load_custom_templates(self) -> Dict[str, Template]:
        """Load custom templates from disk."""
        templates = {}
        
        try:
            for template_file in self.custom_template_dir.glob("*.json"):
                try:
                    with open(template_file, 'r') as f:
                        template_dict = json.load(f)
                    
                    # Convert dict back to Template object
                    metadata_dict = template_dict['metadata']
                    metadata_dict['template_type'] = TemplateType(metadata_dict['template_type'])
                    
                    metadata = TemplateMetadata(**metadata_dict)
                    
                    template = Template(
                        metadata=metadata,
                        content=template_dict['content'],
                        variables=template_dict.get('variables', {}),
                        validation_rules=template_dict.get('validation_rules'),
                        dependencies=template_dict.get('dependencies')
                    )
                    
                    template_name = template_file.stem
                    templates[template_name] = template
                    
                except Exception as e:
                    logger.error("Failed to load custom template", file=str(template_file), error=str(e))
        
        except Exception as e:
            logger.error("Failed to load custom templates", error=str(e))
        
        return templates
    
    def delete_custom_template(self, name: str):
        """
        Delete a custom template.
        
        Args:
            name: Template name
            
        Raises:
            TemplateError: If template not found or deletion fails
        """
        try:
            template_file = self.custom_template_dir / f"{name}.json"
            
            if not template_file.exists():
                raise TemplateError(f"Custom template '{name}' not found")
            
            template_file.unlink()
            
            log_security_event(
                "Custom template deleted",
                success=True,
                details={'template_name': name}
            )
            
            logger.info("Custom template deleted", name=name)
            
        except Exception as e:
            logger.error("Failed to delete custom template", name=name, error=str(e))
            raise TemplateError(f"Failed to delete template: {e}")
    
    def export_template(self, name: str, export_path: Path):
        """
        Export a template to a file.
        
        Args:
            name: Template name
            export_path: Path to export file
        """
        try:
            template = self.get_template(name)
            
            export_data = {
                'metadata': asdict(template.metadata),
                'content': template.content,
                'variables': template.variables,
                'validation_rules': template.validation_rules,
                'dependencies': template.dependencies
            }
            
            # Convert enum to string
            export_data['metadata']['template_type'] = template.metadata.template_type.value
            
            with open(export_path, 'w') as f:
                json.dump(export_data, f, indent=2)
            
            logger.info("Template exported", name=name, export_path=str(export_path))
            
        except Exception as e:
            logger.error("Failed to export template", name=name, error=str(e))
            raise TemplateError(f"Failed to export template: {e}")
    
    def import_template(self, import_path: Path, name: Optional[str] = None) -> str:
        """
        Import a template from a file.
        
        Args:
            import_path: Path to template file
            name: Optional custom name for imported template
            
        Returns:
            Name of imported template
        """
        try:
            with open(import_path, 'r') as f:
                template_dict = json.load(f)
            
            # Convert dict back to Template object
            metadata_dict = template_dict['metadata']
            metadata_dict['template_type'] = TemplateType(metadata_dict['template_type'])
            
            metadata = TemplateMetadata(**metadata_dict)
            
            template = Template(
                metadata=metadata,
                content=template_dict['content'],
                variables=template_dict.get('variables', {}),
                validation_rules=template_dict.get('validation_rules'),
                dependencies=template_dict.get('dependencies')
            )
            
            # Use provided name or original name
            template_name = name or metadata.name.lower().replace(' ', '-')
            
            # Save as custom template
            self.save_custom_template(template_name, template, overwrite=True)
            
            logger.info("Template imported", name=template_name, import_path=str(import_path))
            return template_name
            
        except Exception as e:
            logger.error("Failed to import template", import_path=str(import_path), error=str(e))
            raise TemplateError(f"Failed to import template: {e}")


# Convenience functions

def render_vm_template(template_name: str, variables: Dict[str, Any]) -> str:
    """Render a VM template with variables."""
    service = TemplateService()
    return service.render_template(template_name, variables)


def get_available_templates(template_type: Optional[TemplateType] = None) -> Dict[str, Template]:
    """Get available templates of specified type."""
    service = TemplateService()
    return service.list_templates(template_type=template_type)