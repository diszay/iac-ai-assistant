"""
Automated Security Vulnerability Detection System.

This module provides comprehensive security vulnerability scanning for generated
infrastructure code, configuration files, and deployment scripts. Optimized for
Intel N150 hardware with efficient scanning algorithms and caching.
"""

import re
import json
import time
import asyncio
import hashlib
from typing import Dict, List, Optional, Tuple, Any, Set, Union
from dataclasses import dataclass, field
from collections import defaultdict
from enum import Enum
from pathlib import Path

import structlog

# Security scanning libraries
try:
    import bandit
    from bandit.core import manager as bandit_manager
    BANDIT_AVAILABLE = True
except ImportError:
    BANDIT_AVAILABLE = False

try:
    import safety
    SAFETY_AVAILABLE = True
except ImportError:
    SAFETY_AVAILABLE = False

# YAML and JSON parsing
import yaml

from ..core.hardware_detector import hardware_detector
from ..core.performance_monitor import PerformanceMonitor

logger = structlog.get_logger(__name__)


class VulnerabilitySeverity(Enum):
    """Severity levels for vulnerabilities."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityType(Enum):
    """Types of vulnerabilities."""
    HARDCODED_SECRET = "hardcoded_secret"
    WEAK_CRYPTO = "weak_crypto"
    INSECURE_PROTOCOL = "insecure_protocol"
    WEAK_AUTHENTICATION = "weak_authentication"
    EXCESSIVE_PERMISSIONS = "excessive_permissions"
    INSECURE_CONFIGURATION = "insecure_configuration"
    INJECTION_RISK = "injection_risk"
    EXPOSED_SERVICE = "exposed_service"
    UNENCRYPTED_DATA = "unencrypted_data"
    WEAK_PASSWORD_POLICY = "weak_password_policy"
    MISSING_SECURITY_HEADER = "missing_security_header"
    OUTDATED_SOFTWARE = "outdated_software"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DATA_EXPOSURE = "data_exposure"
    NETWORK_SECURITY = "network_security"


@dataclass
class SecurityVulnerability:
    """Represents a detected security vulnerability."""
    
    id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    vulnerability_type: VulnerabilityType
    confidence: float  # 0.0 to 1.0
    
    # Location information
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    column_number: Optional[int] = None
    code_snippet: Optional[str] = None
    
    # Fix information
    fix_suggestion: str = ""
    fix_examples: Dict[str, str] = field(default_factory=dict)
    fix_effort: str = "medium"  # low, medium, high
    
    # Context and metadata
    cve_ids: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    created_at: float = field(default_factory=time.time)
    
    # Risk assessment
    exploitability: str = "medium"  # low, medium, high
    impact: str = "medium"  # low, medium, high
    false_positive_risk: float = 0.1


@dataclass
class SecurityScanResult:
    """Results of a security scan."""
    
    scan_id: str
    scan_type: str
    target: str  # file path or code content hash
    
    vulnerabilities: List[SecurityVulnerability] = field(default_factory=list)
    scan_duration: float = 0.0
    scan_timestamp: float = field(default_factory=time.time)
    
    # Summary statistics
    critical_count: int = 0
    high_count: int = 0
    medium_count: int = 0
    low_count: int = 0
    info_count: int = 0
    
    # Scan metadata
    rules_applied: List[str] = field(default_factory=list)
    scan_coverage: Dict[str, bool] = field(default_factory=dict)
    false_positive_rate: float = 0.0
    
    def __post_init__(self):
        """Calculate summary statistics."""
        for vuln in self.vulnerabilities:
            if vuln.severity == VulnerabilitySeverity.CRITICAL:
                self.critical_count += 1
            elif vuln.severity == VulnerabilitySeverity.HIGH:
                self.high_count += 1
            elif vuln.severity == VulnerabilitySeverity.MEDIUM:
                self.medium_count += 1
            elif vuln.severity == VulnerabilitySeverity.LOW:
                self.low_count += 1
            elif vuln.severity == VulnerabilitySeverity.INFO:
                self.info_count += 1


class SecurityRuleEngine:
    """Rule-based security vulnerability detection engine."""
    
    def __init__(self):
        self.rules = self._load_security_rules()
        self.terraform_rules = self._load_terraform_security_rules()
        self.ansible_rules = self._load_ansible_security_rules()
        self.kubernetes_rules = self._load_kubernetes_security_rules()
        self.bash_rules = self._load_bash_security_rules()
        
        logger.info("Security rule engine initialized")
    
    def _load_security_rules(self) -> Dict[str, List[Dict[str, Any]]]:
        """Load general security rules."""
        return {
            "hardcoded_secrets": [
                {
                    "id": "SEC001",
                    "pattern": r'(?i)(password|passwd|pwd)\s*[:=]\s*["\']([^"\']{8,})["\']',
                    "title": "Hardcoded Password",
                    "description": "Hardcoded password detected in configuration",
                    "severity": VulnerabilitySeverity.CRITICAL,
                    "fix": "Use environment variables or secure secret management"
                },
                {
                    "id": "SEC002", 
                    "pattern": r'(?i)(api[_-]?key|apikey|secret[_-]?key)\s*[:=]\s*["\']([^"\']{16,})["\']',
                    "title": "Hardcoded API Key",
                    "description": "Hardcoded API key or secret detected",
                    "severity": VulnerabilitySeverity.CRITICAL,
                    "fix": "Use secure secret management system"
                },
                {
                    "id": "SEC003",
                    "pattern": r'(?i)(token|access[_-]?token)\s*[:=]\s*["\']([^"\']{20,})["\']',
                    "title": "Hardcoded Token",
                    "description": "Hardcoded access token detected",
                    "severity": VulnerabilitySeverity.HIGH,
                    "fix": "Use secure token storage and rotation"
                }
            ],
            
            "weak_crypto": [
                {
                    "id": "SEC004",
                    "pattern": r'(?i)(md5|sha1)\s*\(',
                    "title": "Weak Cryptographic Hash",
                    "description": "Use of weak cryptographic hash function (MD5/SHA1)",
                    "severity": VulnerabilitySeverity.HIGH,
                    "fix": "Use SHA-256 or stronger hash functions"
                },
                {
                    "id": "SEC005",
                    "pattern": r'(?i)ssl[_-]?protocol\s*[:=]\s*["\']?(ssl|tls)v?[12]["\']?',
                    "title": "Weak SSL/TLS Version",
                    "description": "Use of deprecated SSL/TLS version",
                    "severity": VulnerabilitySeverity.HIGH,
                    "fix": "Use TLS 1.2 or higher"
                }
            ],
            
            "insecure_protocols": [
                {
                    "id": "SEC006",
                    "pattern": r'http://(?!localhost|127\.0\.0\.1|0\.0\.0\.0)',
                    "title": "Insecure HTTP Protocol",
                    "description": "Use of insecure HTTP protocol for external connections",
                    "severity": VulnerabilitySeverity.MEDIUM,
                    "fix": "Use HTTPS for all external connections"
                },
                {
                    "id": "SEC007",
                    "pattern": r'(?i)ftp://|telnet://',
                    "title": "Insecure Protocol Usage",
                    "description": "Use of insecure protocols (FTP/Telnet)",
                    "severity": VulnerabilitySeverity.HIGH,
                    "fix": "Use secure alternatives (SFTP/SSH)"
                }
            ],
            
            "excessive_permissions": [
                {
                    "id": "SEC008",
                    "pattern": r'chmod\s+777',
                    "title": "Excessive File Permissions",
                    "description": "Setting overly permissive file permissions (777)",
                    "severity": VulnerabilitySeverity.HIGH,
                    "fix": "Use least privilege principle for file permissions"
                },
                {
                    "id": "SEC009",
                    "pattern": r'(?i)sudo\s+.*\$\{.*\}',
                    "title": "Unsafe Sudo Usage",
                    "description": "Potentially unsafe sudo command with variable substitution",
                    "severity": VulnerabilitySeverity.MEDIUM,
                    "fix": "Validate variables before using in sudo commands"
                }
            ]
        }
    
    def _load_terraform_security_rules(self) -> List[Dict[str, Any]]:
        """Load Terraform-specific security rules."""
        return [
            {
                "id": "TF001",
                "pattern": r'resource\s+"aws_s3_bucket"\s+"[^"]+"\s*{\s*[^}]*acl\s*=\s*"public-read"',
                "title": "Public S3 Bucket",
                "description": "S3 bucket configured with public read access",
                "severity": VulnerabilitySeverity.HIGH,
                "fix": "Restrict S3 bucket access using proper ACLs and bucket policies"
            },
            {
                "id": "TF002",
                "pattern": r'resource\s+"aws_security_group_rule"\s+"[^"]+"\s*{\s*[^}]*cidr_blocks\s*=\s*\["0\.0\.0\.0/0"\]',
                "title": "Overly Permissive Security Group",
                "description": "Security group rule allows access from anywhere (0.0.0.0/0)",
                "severity": VulnerabilitySeverity.HIGH,
                "fix": "Restrict CIDR blocks to specific IP ranges"
            },
            {
                "id": "TF003",
                "pattern": r'resource\s+"aws_instance"\s+"[^"]+"\s*{\s*[^}]*associate_public_ip_address\s*=\s*true',
                "title": "Public IP Assignment",
                "description": "EC2 instance configured with public IP address",
                "severity": VulnerabilitySeverity.MEDIUM,
                "fix": "Use private subnets and NAT gateway for internet access"
            },
            {
                "id": "TF004",
                "pattern": r'(?i)password\s*=\s*"[^"]*"',
                "title": "Hardcoded Password in Terraform",
                "description": "Password hardcoded in Terraform configuration",
                "severity": VulnerabilitySeverity.CRITICAL,
                "fix": "Use Terraform variables or AWS Secrets Manager"
            }
        ]
    
    def _load_ansible_security_rules(self) -> List[Dict[str, Any]]:
        """Load Ansible-specific security rules."""
        return [
            {
                "id": "ANS001",
                "pattern": r'(?i)become:\s*yes.*no_log:\s*false',
                "title": "Privileged Task Without no_log",
                "description": "Privileged task may log sensitive information",
                "severity": VulnerabilitySeverity.MEDIUM,
                "fix": "Add 'no_log: true' to tasks handling sensitive data"
            },
            {
                "id": "ANS002",
                "pattern": r'(?i)shell:.*\$\{[^}]+\}',
                "title": "Shell Injection Risk",
                "description": "Shell command with variable substitution may be vulnerable to injection",
                "severity": VulnerabilitySeverity.HIGH,
                "fix": "Use Ansible modules instead of shell commands or validate input"
            },
            {
                "id": "ANS003",
                "pattern": r'(?i)user:.*password:\s*"[^"]*"',
                "title": "Hardcoded User Password",
                "description": "User password hardcoded in playbook",
                "severity": VulnerabilitySeverity.CRITICAL,
                "fix": "Use Ansible Vault for password encryption"
            },
            {
                "id": "ANS004",
                "pattern": r'(?i)become_user:\s*root.*become_method:\s*su',
                "title": "Insecure Privilege Escalation",
                "description": "Using 'su' for privilege escalation is less secure than 'sudo'",
                "severity": VulnerabilitySeverity.MEDIUM,
                "fix": "Use 'sudo' instead of 'su' for privilege escalation"
            }
        ]
    
    def _load_kubernetes_security_rules(self) -> List[Dict[str, Any]]:
        """Load Kubernetes-specific security rules."""
        return [
            {
                "id": "K8S001",
                "pattern": r'(?i)privileged:\s*true',
                "title": "Privileged Container",
                "description": "Container running in privileged mode",
                "severity": VulnerabilitySeverity.HIGH,
                "fix": "Remove privileged mode or use specific capabilities"
            },
            {
                "id": "K8S002",
                "pattern": r'(?i)runAsUser:\s*0',
                "title": "Container Running as Root",
                "description": "Container configured to run as root user",
                "severity": VulnerabilitySeverity.HIGH,
                "fix": "Configure container to run as non-root user"
            },
            {
                "id": "K8S003",
                "pattern": r'(?i)allowPrivilegeEscalation:\s*true',
                "title": "Privilege Escalation Allowed",
                "description": "Container allows privilege escalation",
                "severity": VulnerabilitySeverity.MEDIUM,
                "fix": "Set allowPrivilegeEscalation to false"
            },
            {
                "id": "K8S004",
                "pattern": r'(?i)hostNetwork:\s*true',
                "title": "Host Network Access",
                "description": "Pod configured to use host network",
                "severity": VulnerabilitySeverity.HIGH,
                "fix": "Use pod networking instead of host networking"
            },
            {
                "id": "K8S005",
                "pattern": r'(?i)image:\s*[^:\s]+\s*$',
                "title": "Image Without Tag",
                "description": "Container image without specific tag (uses 'latest')",
                "severity": VulnerabilitySeverity.MEDIUM,
                "fix": "Specify exact image tags for reproducible deployments"
            }
        ]
    
    def _load_bash_security_rules(self) -> List[Dict[str, Any]]:
        """Load Bash-specific security rules."""
        return [
            {
                "id": "BASH001",
                "pattern": r'eval\s+\$',
                "title": "Dangerous eval Usage",
                "description": "Use of eval with variable may lead to code injection",
                "severity": VulnerabilitySeverity.HIGH,
                "fix": "Avoid eval or validate input thoroughly"
            },
            {
                "id": "BASH002",
                "pattern": r'curl.*http://.*\|\s*bash',
                "title": "Insecure Script Download",
                "description": "Downloading and executing script over insecure HTTP",
                "severity": VulnerabilitySeverity.HIGH,
                "fix": "Use HTTPS and verify script integrity"
            },
            {
                "id": "BASH003",
                "pattern": r'rm\s+-rf\s+\$',
                "title": "Dangerous File Deletion",
                "description": "Potentially dangerous recursive file deletion with variable",
                "severity": VulnerabilitySeverity.HIGH,
                "fix": "Validate variable content before file operations"
            },
            {
                "id": "BASH004",
                "pattern": r'(?i)password\s*=\s*["\']([^"\']+)["\']',
                "title": "Hardcoded Password in Script",
                "description": "Password hardcoded in shell script",
                "severity": VulnerabilitySeverity.CRITICAL,
                "fix": "Use environment variables or secure credential storage"
            }
        ]
    
    async def scan_content(self, content: str, file_type: str, file_path: str = "") -> List[SecurityVulnerability]:
        """Scan content for security vulnerabilities."""
        vulnerabilities = []
        
        # Apply general rules
        for category, rules in self.rules.items():
            for rule in rules:
                matches = re.finditer(rule["pattern"], content, re.MULTILINE | re.IGNORECASE)
                for match in matches:
                    line_number = content[:match.start()].count('\n') + 1
                    
                    vulnerability = SecurityVulnerability(
                        id=rule["id"],
                        title=rule["title"],
                        description=rule["description"],
                        severity=rule["severity"],
                        vulnerability_type=self._map_to_vulnerability_type(category),
                        confidence=0.8,
                        file_path=file_path,
                        line_number=line_number,
                        code_snippet=self._extract_code_snippet(content, match.start(), match.end()),
                        fix_suggestion=rule["fix"]
                    )
                    vulnerabilities.append(vulnerability)
        
        # Apply file-type specific rules
        if file_type == "terraform":
            vulnerabilities.extend(await self._scan_terraform_specific(content, file_path))
        elif file_type == "ansible":
            vulnerabilities.extend(await self._scan_ansible_specific(content, file_path))
        elif file_type == "kubernetes":
            vulnerabilities.extend(await self._scan_kubernetes_specific(content, file_path))
        elif file_type == "bash":
            vulnerabilities.extend(await self._scan_bash_specific(content, file_path))
        
        return vulnerabilities
    
    async def _scan_terraform_specific(self, content: str, file_path: str) -> List[SecurityVulnerability]:
        """Scan Terraform-specific vulnerabilities."""
        vulnerabilities = []
        
        for rule in self.terraform_rules:
            matches = re.finditer(rule["pattern"], content, re.MULTILINE | re.IGNORECASE)
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1
                
                vulnerability = SecurityVulnerability(
                    id=rule["id"],
                    title=rule["title"],
                    description=rule["description"],
                    severity=rule["severity"],
                    vulnerability_type=VulnerabilityType.INSECURE_CONFIGURATION,
                    confidence=0.85,
                    file_path=file_path,
                    line_number=line_number,
                    code_snippet=self._extract_code_snippet(content, match.start(), match.end()),
                    fix_suggestion=rule["fix"]
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    async def _scan_ansible_specific(self, content: str, file_path: str) -> List[SecurityVulnerability]:
        """Scan Ansible-specific vulnerabilities."""
        vulnerabilities = []
        
        for rule in self.ansible_rules:
            matches = re.finditer(rule["pattern"], content, re.MULTILINE | re.IGNORECASE)
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1
                
                vulnerability = SecurityVulnerability(
                    id=rule["id"],
                    title=rule["title"],
                    description=rule["description"],
                    severity=rule["severity"],
                    vulnerability_type=VulnerabilityType.INSECURE_CONFIGURATION,
                    confidence=0.80,
                    file_path=file_path,
                    line_number=line_number,
                    code_snippet=self._extract_code_snippet(content, match.start(), match.end()),
                    fix_suggestion=rule["fix"]
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    async def _scan_kubernetes_specific(self, content: str, file_path: str) -> List[SecurityVulnerability]:
        """Scan Kubernetes-specific vulnerabilities."""
        vulnerabilities = []
        
        for rule in self.kubernetes_rules:
            matches = re.finditer(rule["pattern"], content, re.MULTILINE | re.IGNORECASE)
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1
                
                vulnerability = SecurityVulnerability(
                    id=rule["id"],
                    title=rule["title"],
                    description=rule["description"],
                    severity=rule["severity"],
                    vulnerability_type=VulnerabilityType.INSECURE_CONFIGURATION,
                    confidence=0.85,
                    file_path=file_path,
                    line_number=line_number,
                    code_snippet=self._extract_code_snippet(content, match.start(), match.end()),
                    fix_suggestion=rule["fix"]
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    async def _scan_bash_specific(self, content: str, file_path: str) -> List[SecurityVulnerability]:
        """Scan Bash-specific vulnerabilities."""
        vulnerabilities = []
        
        for rule in self.bash_rules:
            matches = re.finditer(rule["pattern"], content, re.MULTILINE | re.IGNORECASE)
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1
                
                vulnerability = SecurityVulnerability(
                    id=rule["id"],
                    title=rule["title"],
                    description=rule["description"],
                    severity=rule["severity"],
                    vulnerability_type=VulnerabilityType.INJECTION_RISK,
                    confidence=0.80,
                    file_path=file_path,
                    line_number=line_number,
                    code_snippet=self._extract_code_snippet(content, match.start(), match.end()),
                    fix_suggestion=rule["fix"]
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _map_to_vulnerability_type(self, category: str) -> VulnerabilityType:
        """Map rule category to vulnerability type."""
        mapping = {
            "hardcoded_secrets": VulnerabilityType.HARDCODED_SECRET,
            "weak_crypto": VulnerabilityType.WEAK_CRYPTO,
            "insecure_protocols": VulnerabilityType.INSECURE_PROTOCOL,
            "excessive_permissions": VulnerabilityType.EXCESSIVE_PERMISSIONS
        }
        return mapping.get(category, VulnerabilityType.INSECURE_CONFIGURATION)
    
    def _extract_code_snippet(self, content: str, start: int, end: int, context_lines: int = 2) -> str:
        """Extract code snippet with context around the vulnerability."""
        lines = content.split('\n')
        line_number = content[:start].count('\n')
        
        start_line = max(0, line_number - context_lines)
        end_line = min(len(lines), line_number + context_lines + 1)
        
        snippet_lines = []
        for i in range(start_line, end_line):
            marker = ">>> " if i == line_number else "    "
            snippet_lines.append(f"{marker}{i+1:3d}: {lines[i]}")
        
        return '\n'.join(snippet_lines)


class ConfigurationSecurityAnalyzer:
    """Analyzes configuration files for security issues."""
    
    def __init__(self):
        self.performance_monitor = PerformanceMonitor()
        
    async def analyze_yaml_config(self, content: str, config_type: str = "general") -> List[SecurityVulnerability]:
        """Analyze YAML configuration for security issues."""
        vulnerabilities = []
        
        try:
            # Parse YAML content
            config = yaml.safe_load(content)
            
            # Check for common security misconfigurations
            vulnerabilities.extend(await self._check_yaml_secrets(config, content))
            vulnerabilities.extend(await self._check_yaml_permissions(config, content))
            vulnerabilities.extend(await self._check_yaml_network_security(config, content))
            
        except yaml.YAMLError as e:
            # YAML parsing error might indicate security issue
            vulnerability = SecurityVulnerability(
                id="YAML001",
                title="YAML Parsing Error",
                description=f"YAML parsing error: {str(e)}",
                severity=VulnerabilitySeverity.LOW,
                vulnerability_type=VulnerabilityType.INSECURE_CONFIGURATION,
                confidence=0.5,
                fix_suggestion="Fix YAML syntax errors"
            )
            vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    async def _check_yaml_secrets(self, config: Any, content: str) -> List[SecurityVulnerability]:
        """Check for secrets in YAML configuration."""
        vulnerabilities = []
        
        def search_secrets(obj, path=""):
            if isinstance(obj, dict):
                for key, value in obj.items():
                    current_path = f"{path}.{key}" if path else key
                    
                    # Check for secret-like keys
                    if any(secret_key in key.lower() for secret_key in ['password', 'secret', 'key', 'token']):
                        if isinstance(value, str) and len(value) > 8:
                            vulnerabilities.append(SecurityVulnerability(
                                id="YAML_SEC001",
                                title="Potential Secret in YAML",
                                description=f"Potential secret found in key '{current_path}'",
                                severity=VulnerabilitySeverity.HIGH,
                                vulnerability_type=VulnerabilityType.HARDCODED_SECRET,
                                confidence=0.7,
                                fix_suggestion="Use environment variables or secret management"
                            ))
                    
                    search_secrets(value, current_path)
            
            elif isinstance(obj, list):
                for i, item in enumerate(obj):
                    search_secrets(item, f"{path}[{i}]")
        
        search_secrets(config)
        return vulnerabilities
    
    async def _check_yaml_permissions(self, config: Any, content: str) -> List[SecurityVulnerability]:
        """Check for permission-related issues in YAML."""
        vulnerabilities = []
        
        # Check for overly permissive settings
        if isinstance(config, dict):
            # Check for world-readable permissions
            if 'permissions' in config:
                perms = config['permissions']
                if isinstance(perms, str) and ('777' in perms or '666' in perms):
                    vulnerabilities.append(SecurityVulnerability(
                        id="YAML_PERM001",
                        title="Excessive Permissions in YAML",
                        description="Overly permissive file permissions detected",
                        severity=VulnerabilitySeverity.MEDIUM,
                        vulnerability_type=VulnerabilityType.EXCESSIVE_PERMISSIONS,
                        confidence=0.8,
                        fix_suggestion="Use restrictive permissions (644 for files, 755 for directories)"
                    ))
        
        return vulnerabilities
    
    async def _check_yaml_network_security(self, config: Any, content: str) -> List[SecurityVulnerability]:
        """Check for network security issues in YAML."""
        vulnerabilities = []
        
        # Check for insecure network configurations
        def check_network_config(obj):
            if isinstance(obj, dict):
                for key, value in obj.items():
                    if 'host' in key.lower() or 'url' in key.lower():
                        if isinstance(value, str) and value.startswith('http://'):
                            vulnerabilities.append(SecurityVulnerability(
                                id="YAML_NET001",
                                title="Insecure HTTP URL in YAML",
                                description=f"Insecure HTTP URL found: {value}",
                                severity=VulnerabilitySeverity.MEDIUM,
                                vulnerability_type=VulnerabilityType.INSECURE_PROTOCOL,
                                confidence=0.9,
                                fix_suggestion="Use HTTPS instead of HTTP"
                            ))
                    
                    if isinstance(value, (dict, list)):
                        check_network_config(value)
                        
            elif isinstance(obj, list):
                for item in obj:
                    if isinstance(item, (dict, list)):
                        check_network_config(item)
        
        check_network_config(config)
        return vulnerabilities


class SecurityVulnerabilityScanner:
    """Main security vulnerability scanner with enterprise features."""
    
    def __init__(self):
        self.rule_engine = SecurityRuleEngine()
        self.config_analyzer = ConfigurationSecurityAnalyzer()
        self.performance_monitor = PerformanceMonitor()
        
        # Caching for performance optimization
        self.scan_cache = {}
        self.cache_ttl = 300  # 5 minutes
        self.max_cache_size = 100  # Limit for Intel N150
        
        logger.info("Security vulnerability scanner initialized")
    
    def _get_content_hash(self, content: str) -> str:
        """Generate hash for content caching."""
        return hashlib.md5(content.encode()).hexdigest()[:16]
    
    async def scan_code(self, 
                       content: str, 
                       file_type: str, 
                       file_path: str = "",
                       use_cache: bool = True) -> SecurityScanResult:
        """Scan code content for security vulnerabilities."""
        start_time = time.time()
        scan_id = f"scan_{int(time.time())}_{hash(content) % 10000}"
        
        # Check cache
        if use_cache:
            content_hash = self._get_content_hash(content)
            cache_key = f"{content_hash}:{file_type}"
            
            if cache_key in self.scan_cache:
                cache_entry = self.scan_cache[cache_key]
                if time.time() - cache_entry["timestamp"] < self.cache_ttl:
                    logger.debug("Using cached security scan results")
                    return cache_entry["result"]
        
        try:
            vulnerabilities = []
            
            # Rule-based scanning
            rule_vulns = await self.rule_engine.scan_content(content, file_type, file_path)
            vulnerabilities.extend(rule_vulns)
            
            # Configuration-specific analysis
            if file_type in ["yaml", "yml"]:
                config_vulns = await self.config_analyzer.analyze_yaml_config(content)
                vulnerabilities.extend(config_vulns)
            
            # Remove duplicates
            vulnerabilities = self._deduplicate_vulnerabilities(vulnerabilities)
            
            # Create scan result
            result = SecurityScanResult(
                scan_id=scan_id,
                scan_type="code_scan",
                target=file_path or content_hash,
                vulnerabilities=vulnerabilities,
                scan_duration=time.time() - start_time,
                rules_applied=[rule["id"] for rules in self.rule_engine.rules.values() for rule in rules]
            )
            
            # Cache result
            if use_cache and len(self.scan_cache) < self.max_cache_size:
                self.scan_cache[cache_key] = {
                    "result": result,
                    "timestamp": time.time()
                }
            
            logger.info(
                "Security scan completed",
                scan_id=scan_id,
                vulnerabilities_found=len(vulnerabilities),
                scan_duration=result.scan_duration
            )
            
            return result
            
        except Exception as e:
            logger.error("Security scan failed", scan_id=scan_id, error=str(e))
            return SecurityScanResult(
                scan_id=scan_id,
                scan_type="code_scan",
                target=file_path or "unknown",
                scan_duration=time.time() - start_time
            )
    
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[SecurityVulnerability]) -> List[SecurityVulnerability]:
        """Remove duplicate vulnerabilities."""
        seen = set()
        unique_vulns = []
        
        for vuln in vulnerabilities:
            # Create unique key based on type, location, and title
            key = (
                vuln.vulnerability_type,
                vuln.file_path,
                vuln.line_number,
                vuln.title
            )
            
            if key not in seen:
                seen.add(key)
                unique_vulns.append(vuln)
        
        return unique_vulns
    
    async def scan_directory(self, directory_path: str, file_patterns: Optional[List[str]] = None) -> List[SecurityScanResult]:
        """Scan entire directory for security vulnerabilities."""
        results = []
        
        if file_patterns is None:
            file_patterns = ["*.tf", "*.yml", "*.yaml", "*.sh", "*.py", "*.json"]
        
        try:
            from pathlib import Path
            directory = Path(directory_path)
            
            if not directory.exists():
                logger.error(f"Directory not found: {directory_path}")
                return results
            
            # Find files matching patterns
            files_to_scan = []
            for pattern in file_patterns:
                files_to_scan.extend(directory.rglob(pattern))
            
            # Scan each file
            for file_path in files_to_scan:
                try:
                    content = file_path.read_text(encoding='utf-8')
                    file_type = self._detect_file_type(file_path.suffix)
                    
                    result = await self.scan_code(content, file_type, str(file_path))
                    results.append(result)
                    
                except Exception as e:
                    logger.warning(f"Failed to scan file {file_path}", error=str(e))
            
            logger.info(f"Directory scan completed: {len(results)} files scanned")
            
        except Exception as e:
            logger.error("Directory scan failed", error=str(e))
        
        return results
    
    def _detect_file_type(self, file_extension: str) -> str:
        """Detect file type from extension."""
        extension_map = {
            '.tf': 'terraform',
            '.yml': 'yaml',
            '.yaml': 'yaml',
            '.sh': 'bash',
            '.py': 'python',
            '.json': 'json',
            '.js': 'javascript',
            '.ts': 'typescript'
        }
        return extension_map.get(file_extension.lower(), 'text')
    
    async def generate_security_report(self, scan_results: List[SecurityScanResult]) -> Dict[str, Any]:
        """Generate comprehensive security report."""
        if not scan_results:
            return {"error": "No scan results provided"}
        
        total_vulns = sum(len(result.vulnerabilities) for result in scan_results)
        
        # Aggregate statistics
        severity_counts = defaultdict(int)
        type_counts = defaultdict(int)
        file_counts = defaultdict(int)
        
        critical_vulns = []
        high_vulns = []
        
        for result in scan_results:
            for vuln in result.vulnerabilities:
                severity_counts[vuln.severity.value] += 1
                type_counts[vuln.vulnerability_type.value] += 1
                
                if vuln.file_path:
                    file_counts[vuln.file_path] += 1
                
                if vuln.severity == VulnerabilitySeverity.CRITICAL:
                    critical_vulns.append(vuln)
                elif vuln.severity == VulnerabilitySeverity.HIGH:
                    high_vulns.append(vuln)
        
        # Calculate risk score
        risk_score = (
            severity_counts['critical'] * 10 +
            severity_counts['high'] * 7 +
            severity_counts['medium'] * 4 +
            severity_counts['low'] * 1
        )
        
        # Generate recommendations
        recommendations = self._generate_security_recommendations(scan_results)
        
        report = {
            "summary": {
                "total_files_scanned": len(scan_results),
                "total_vulnerabilities": total_vulns,
                "risk_score": risk_score,
                "scan_timestamp": time.time()
            },
            "severity_breakdown": dict(severity_counts),
            "vulnerability_types": dict(type_counts),
            "most_vulnerable_files": dict(sorted(file_counts.items(), key=lambda x: x[1], reverse=True)[:10]),
            "critical_vulnerabilities": [
                {
                    "title": vuln.title,
                    "file": vuln.file_path,
                    "line": vuln.line_number,
                    "description": vuln.description,
                    "fix": vuln.fix_suggestion
                }
                for vuln in critical_vulns[:5]
            ],
            "high_priority_vulnerabilities": [
                {
                    "title": vuln.title,
                    "file": vuln.file_path,
                    "line": vuln.line_number,
                    "description": vuln.description,
                    "fix": vuln.fix_suggestion
                }
                for vuln in high_vulns[:10]
            ],
            "recommendations": recommendations,
            "scan_details": [
                {
                    "scan_id": result.scan_id,
                    "target": result.target,
                    "vulnerabilities_count": len(result.vulnerabilities),
                    "scan_duration": result.scan_duration
                }
                for result in scan_results
            ]
        }
        
        return report
    
    def _generate_security_recommendations(self, scan_results: List[SecurityScanResult]) -> List[str]:
        """Generate security recommendations based on scan results."""
        recommendations = []
        
        # Count vulnerability types
        type_counts = defaultdict(int)
        for result in scan_results:
            for vuln in result.vulnerabilities:
                type_counts[vuln.vulnerability_type] += 1
        
        # Generate type-specific recommendations
        if type_counts[VulnerabilityType.HARDCODED_SECRET] > 0:
            recommendations.append("Implement a secrets management system (HashiCorp Vault, AWS Secrets Manager)")
        
        if type_counts[VulnerabilityType.WEAK_CRYPTO] > 0:
            recommendations.append("Update cryptographic implementations to use strong algorithms (SHA-256+, AES-256)")
        
        if type_counts[VulnerabilityType.INSECURE_PROTOCOL] > 0:
            recommendations.append("Migrate from insecure protocols (HTTP, FTP) to secure alternatives (HTTPS, SFTP)")
        
        if type_counts[VulnerabilityType.EXCESSIVE_PERMISSIONS] > 0:
            recommendations.append("Implement least privilege principle for all file and system permissions")
        
        if type_counts[VulnerabilityType.INSECURE_CONFIGURATION] > 0:
            recommendations.append("Establish security configuration baselines and automated compliance checking")
        
        return recommendations
    
    def clear_cache(self):
        """Clear scan cache."""
        self.scan_cache.clear()
        logger.info("Security scan cache cleared")


# Global security scanner instance
security_scanner = None

def get_security_scanner() -> SecurityVulnerabilityScanner:
    """Get global security scanner instance."""
    global security_scanner
    
    if security_scanner is None:
        security_scanner = SecurityVulnerabilityScanner()
    
    return security_scanner


# Quick scan function for CLI usage
async def quick_security_scan(code: str, file_type: str = "text") -> Dict[str, Any]:
    """Quick security scan for CLI usage."""
    scanner = get_security_scanner()
    result = await scanner.scan_code(code, file_type)
    
    return {
        "vulnerabilities_found": len(result.vulnerabilities),
        "critical_count": result.critical_count,
        "high_count": result.high_count,
        "medium_count": result.medium_count,
        "scan_duration": result.scan_duration,
        "top_vulnerabilities": [
            {
                "title": vuln.title,
                "severity": vuln.severity.value,
                "description": vuln.description,
                "fix": vuln.fix_suggestion
            }
            for vuln in sorted(result.vulnerabilities, 
                             key=lambda x: (x.severity.value == "critical", x.confidence), 
                             reverse=True)[:5]
        ]
    }


# Export main classes and functions
__all__ = [
    'SecurityVulnerability',
    'SecurityScanResult',
    'VulnerabilitySeverity',
    'VulnerabilityType',
    'SecurityVulnerabilityScanner',
    'SecurityRuleEngine',
    'ConfigurationSecurityAnalyzer',
    'get_security_scanner',
    'quick_security_scan'
]